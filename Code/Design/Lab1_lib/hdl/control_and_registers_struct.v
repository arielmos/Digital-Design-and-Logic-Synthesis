//
// Module Lab1_lib.Control_And_Registers.struct
//
// Created:
//          by - amitnag.UNKNOWN (SHOHAM)
//          at - 12:17:15 11/23/2020
//
// Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
//

`resetall
`timescale 1ns/10ps
module Control_And_Registers #(
   // synopsys template
   // synopsys template
// synopsys template
   parameter Amba_Addr_Depth = 20,
   parameter Amba_Word       = 16,
   parameter Data_Depth      = 8
)
( 
   // Port Declarations
   // Port Declarations
   // Port Declarations
   input   wire                              clk,          // system clock
   input   wire                              rst,          //  Reset active low
   input   wire                              ena_in,       //  Reset active low
   // Port Declarations
   // Port Declarations
   input   wire    [Amba_Addr_Depth-1:0]     Address,      // APB Address Bus
   input   wire    [Amba_Word-1:0]           data_in,      // APB Read Data Bu
   output  reg                               ena_out,      // when a block is ready
   output  reg                               Image_Done, 
   input   wire                              Block_Done,   // when block is done
   output  reg     [(10*7)-1:0]              data_params,  //[6:0],
   output  reg     [(Data_Depth*72*72)-1:0]  data_pic,     //[(72*72)-1:0],  // max size of block is 72*72 pixels and size of pixel is DATA_DEPTH
   output  reg     [(Data_Depth*72*72)-1:0]  data_water    //[(72*72)-1:0]
);

// Internal Declarations




// ### Please start your Verilog code here ### 
//-------------------------------------------------------
//-------------------registers -----------------------
//-------------------------------------------------------
// Internal Declarations


// Local declarations

// Internal signal declarations
reg  [Amba_Word-1:0] registers [2**(Amba_Addr_Depth-1):0];
reg  [19:0]          M2;
reg  [19:0]          N2;
//-------------------------------------------------------

//-------------------------------------------------------
//----------------------Block Logic ---------------------
//-------------------------------------------------------
reg  [18:0]          block_i;                                // max 720*720, number of pixels
reg  [12:0]          pixel_i;                                // max pixels in block is 72*72 = 5184
reg  [2:0]           param_i;                                // we have 7 params
reg  [1:0]           state;                                  // 0 - data_pic, 1 - data_water , 2 - data_params


// Instances 
// HDL Embedded Text Block 1 reg_proc
always @(posedge  clk) begin: reg_proc
  if (rst) begin
    registers[0] <=0;
  end
  if (ena_in) begin
    registers[Address] <= data_in;
    if (Address == 4) 
      M2 <= data_in*data_in;
    if (Address == 2) 
      N2 <= data_in*data_in;
  end
end
// HDL Embedded Text Block 2 block_filler
/*
data_pic= pixel_i + start Address pic + block_i*M*M
pixel_i = 0;
data_water= pixel_i + start Address water + block_i*M*M
pixel_i = 0;
data_params[param_i] = 7 clocks, each one with diffrent address

`define M registers[4][9:0] // maybe use assign like this: assign ena_out = registers[0][0];
`define N registers[2][9:0]
*/

always @(posedge  clk) begin: block_filler
  if (rst) begin
    block_i <= 0;
    pixel_i <=0;
    param_i <= 0;
    state <= 0;
    Image_Done <= 0;
  end
  if (registers[0][0] && Block_Done) begin //start_bit == 1
      case (state)
        0: begin//data_pic
          if(pixel_i >= M2) begin//if pixel index >= M^2 finished data_pic
            pixel_i <=0;
            state <= 1;
          end
          else begin
            data_pic[(pixel_i+1)*Data_Depth-1 -: Data_Depth]<= registers[pixel_i + 10 + block_i*M2][Data_Depth-1:0];
            pixel_i <= pixel_i + 1;           
          end
        end// case 0
        
        1: begin//data_water
          if(pixel_i >= M2) begin//if pixel index >= M^2 finished data_pic
              pixel_i <=0;
              state <= 2;
          end
          else begin
              data_water[(pixel_i+1)*Data_Depth-1 -: Data_Depth]<= registers[pixel_i + 10 + N2 + block_i*M2][Data_Depth-1:0];
              pixel_i <= pixel_i + 1;           
          end
        end// case 1
        
        default: begin// state = 2
          if(param_i >= 7) begin// block filler finished
              param_i <=0;
              state <= 0;
              ena_out <= 1;
              block_i <= block_i + 1;
              Image_Done <= 0;
              if (block_i >= (N2)/(M2)) begin
                Image_Done <= 1;
                block_i <= 0;
              end
          end
          else begin
            case (param_i)
              0:   
                data_params[9:0] <= registers[1]; //WhitePixel 7:0
              1:   
                data_params[19:10] <= registers[4]; //BlockSize  9:0
              2:   
                data_params[29:20] <= registers[5]; //EdgeThreshold 7:0
              3:   
                data_params[39:30] <= registers[6]; //Amin 6:0
              4:   
                data_params[49:40] <= registers[7]; //Amax 6:0
              5:   
                data_params[59:50] <= registers[8]; //Bmin 5:0
              default: // pixel_i = 7
                data_params[69:60] <= registers[9]; //Bmax 5:0
            endcase
            param_i <= param_i + 1;
          end// else end
        end
      endcase 
    end
end

endmodule // Control_And_Registers

